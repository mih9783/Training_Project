// Пример без ошибок: при запуске сработают alert (1) и (2):

 try {

     alert('Начало блока try');  // (1) <--
  
     // .. код без ошибок
  
     alert('Конец блока try');   // (2) <--
  
   } catch(e) {
  
     alert('Блок catch не получит управление, так как нет ошибок'); // (3)
  
   }
  
   alert("Потом код продолжит выполнение...");

  
///////////////////////////////////////////////////////////

// Пример с ошибкой: при запуске сработают (1) и (3):

//  try {

//      alert('Начало блока try');  // (1) <--
  
//      lalala; // ошибка, переменная не определена!
  
//      alert('Конец блока try');  // (2)
  
//    } catch(e) {
  
//      alert('Ошибка ' + e.name + ":" + e.message + "\n" + e.stack); // (3) <--
  
//    }
  
//    alert("Потом код продолжит выполнение...");


try {

    alert('Начало блока try');  // (1) <--
 
    alert(lalala); // ошибка, переменная не определена!
 
    alert('Конец блока try');  // (2)
 
  } catch(eror) {
 
    alert(`Ошибка  ${eror.name}  ${eror.message}  ${eror.stack}`); // (3) <--
 
  }
 
  alert("Потом код продолжит выполнение...");

  /*

В JavaScript есть встроенный метод JSON.parse(str), который используется для чтения JavaScript-объектов (и не только) из строки.

Обычно он используется для того, чтобы обрабатывать данные, полученные по сети, с сервера или из другого источника.

Мы получаем их и вызываем метод JSON.parse, вот так:

  */

 let data = '{"name":"Вася", "age": 30}'; // строка с данными, полученная с сервера

 let user = JSON.parse(data); // преобразовали строку в объект
 
 // теперь user -- это JS-объект с данными из строки
 alert( user.name ); // Вася
 alert( user.age ); // 30

 // Используем try..catch, чтобы обработать некорректный ответ:

 let data1 = "Has Error"; // в данных ошибка

try {

  let user1 = JSON.parse(data1); // <-- ошибка при выполнении
  alert( user1.name ); // не сработает

} catch (e) {
  // ...выполнится catch
  alert( "Извините, в данных ошибка, мы попробуем получить их ещё раз" );
  alert( e.name );
  alert( e.message );
}

/*

Здесь в alert только выводится сообщение, но область применения гораздо шире: можно повторять запрос, можно предлагать посетителю использовать альтернативный способ, можно отсылать информацию об ошибке на сервер… Свобода действий.

*/

/*

Для того, чтобы унифицировать и объединить обработку ошибок парсинга и ошибок в структуре, мы воспользуемся оператором throw.

*/

// В качестве конструктора ошибок можно использовать встроенный конструктор: new Error(message) или любой другой.

// В данном случае мы используем конструктор new SyntaxError(message). Он создаёт ошибку того же типа, что и JSON.parse.

let data2 = '{ "age": 30 }'; // данные неполны

try {

  let user2 = JSON.parse(data2); // <-- выполнится без ошибок

  if (!user2.name) {
    throw new SyntaxError("Данные некорректны");
  }

  alert( user2.name );

} catch (e) {
  alert( "Извините, в данных ошибка" );
}

// Получилось, что блок catch – единое место для обработки ошибок во всех случаях: когда ошибка выявляется при JSON.parse или позже.

// Ошибку, о которой catch не знает, он не должен обрабатывать.

/*

Такая техника называется «проброс исключения»: в catch(e) мы анализируем объект ошибки, и если он нам не подходит, то делаем throw e.

При этом ошибка «выпадает» из try..catch наружу. Далее она может быть поймана либо внешним блоком try..catch (если есть), либо «повалит» скрипт.

В примере ниже catch обрабатывает только ошибки SyntaxError, а остальные – выбрасывает дальше:

*/

var data3 = '{ "name": "Вася", "age": 30 }'; // данные корректны

try {

  var user3 = JSON.parse(data);

  if (!user3.name) {
    throw new SyntaxError("Ошибка в данных");
  }

  //blabla(); // произошла непредусмотренная ошибка

  alert( user3.name );

} catch (e) {

  if (e.name == "SyntaxError") {
    alert( "Извините, в данных ошибка" );
  } else {
    throw e;
  }

}

// Петриченко

let json = '{"age": 47}';

try {
    let user5 = JSON.parse(json);

    console.log(user5);

    if(!user5.name) {
        throw new Error("В этих данных нет имени");
    }
} catch(error) {
    console.log(error.name);
    console.log(error.message);
    console.log(error.stack);

    console.log(`Мы получили ошибку: ${error.name}`);
}

console.log("Продолжаем работать дальше");

// /////////////

// Секцию finally используют, чтобы завершить начатые операции при любом варианте развития событий.

/*

Например, мы хотим подсчитать время на выполнение функции sum(n), которая должна возвратить сумму чисел от 1 до n и работает рекурсивно:

*/

function sum(n) {
    return n ? (n + sum(n - 1)) : 0;
  }
  
  var n = +prompt('Введите n?', 100);
  
  var start = new Date();
  
  try {
    var result = sum(n);
  } catch (e) {
    result = 0;
  } finally {
    var diff = new Date() - start;
  }
  
  alert( result ? result : 'была ошибка' );
  alert( "Выполнение заняло " + diff );

  // Здесь секция finally гарантирует, что время будет подсчитано в любых ситуациях: при ошибке в sum или без неё.

  /*
  
   Вы можете проверить это, запустив код с указанием n=100 – будет без ошибки, finally выполнится после try, а затем с n=100000 – будет ошибка из-за слишком глубокой рекурсии, управление прыгнет в finally после catch.
  
  */